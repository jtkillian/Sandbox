name: MATLAB CI + AI Review Loop

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  push:
    branches: [main]            # registers the check on main so it can be required
  workflow_dispatch: {}

permissions:
  contents: read
  pull-requests: write
  issues: write
  models: read

env:
  # Policy / gating
  ALLOWED_BASES: "bot/main,bots/main,dev,main"
  REQUIRED_HEAD_PREFIXES: "bot/copilot-,bot/codex-,bots/copilot-,bots/codex-"
  HUMAN_OWNER: "jtkillian"
  MAX_REVISIONS: "5"
  MIN_COVERAGE: "60"

  # AI controls (quota-safe)
  MODEL_ID: "openai/o4-mini"
  CI_AI_ENABLED: "1"
  CI_AI_ON_SUCCESS: "0"

jobs:
  test-and-review:
    runs-on: ubuntu-latest
    environment: copilot

    steps:
      - name: Checkout (shallow is fine)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Label PR as in-progress
        if: ${{ github.event_name == 'pull_request' }}
        uses: actions-ecosystem/action-add-labels@v1
        with: { labels: "ci:in-progress" }
        continue-on-error: true

      - name: Enforce agent branch policy (bots only)
        if: ${{ github.event_name == 'pull_request' }}
        id: policy
        shell: bash
        run: |
          if [ "${{ github.actor }}" = "${HUMAN_OWNER}" ]; then exit 0; fi
          if [[ "${{ github.head_ref }}" != bot/* && "${{ github.head_ref }}" != bots/* ]]; then
            echo "::error::Head must start with bot/ or bots/."; echo "policy_fail=true" >> $GITHUB_OUTPUT; exit 1; fi
          allowed="${ALLOWED_BASES//,/|}"
          if ! [[ "${{ github.base_ref }}" =~ ^(${allowed})$ ]]; then
            echo "::error::Base must be one of: ${ALLOWED_BASES}"; echo "policy_fail=true" >> $GITHUB_OUTPUT; exit 1; fi
          ok=0; IFS=',' read -ra PFX <<< "$REQUIRED_HEAD_PREFIXES"
          for p in "${PFX[@]}"; do [[ "${{ github.head_ref }}" == $p* ]] && ok=1; done
          if [[ $ok -eq 0 ]]; then
            echo "::error::Head must start with one of: ${REQUIRED_HEAD_PREFIXES}"; echo "policy_fail=true" >> $GITHUB_OUTPUT; exit 1; fi
        continue-on-error: true

      - name: Label wrong-branch policy
        if: ${{ github.event_name == 'pull_request' && steps.policy.outputs.policy_fail == 'true' }}
        uses: actions-ecosystem/action-add-labels@v1
        with: { labels: "policy:wrong-branch" }
        continue-on-error: true

      - name: Determine PR SHAs & fetch just those commits (safe diff)
        if: ${{ github.event_name == 'pull_request' }}
        id: shas
        shell: bash
        run: |
          BASE="${{ github.event.pull_request.base.sha }}"
          HEAD="${{ github.event.pull_request.head.sha }}"
          echo "base=$BASE" >> $GITHUB_OUTPUT
          echo "head=$HEAD" >> $GITHUB_OUTPUT
          git fetch --no-tags --depth=1 origin $BASE $HEAD

      - name: Detect MATLAB availability
        id: detect
        shell: bash
        run: |
          if command -v matlab >/dev/null 2>&1; then
            echo "available=true" >> $GITHUB_OUTPUT
          else
            echo "available=false" >> $GITHUB_OUTPUT
          fi

      # If you acquire a MATLAB token & want setup here later, gate it like:
      # - uses: matlab-actions/setup-matlab@v2
      #   if: ${{ steps.detect.outputs.available == 'true' || secrets.MATHWORKS_TOKEN != '' }}
      #   with:
      #     release: R2024b
      #   env:
      #     MATHWORKS_TOKEN: ${{ secrets.MATHWORKS_TOKEN }}

      - name: Run MATLAB CI (or generate empty reports if unavailable)
        id: run
        shell: bash
        run: |
          mkdir -p test-results code-coverage ci
          if [ "${{ steps.detect.outputs.available }}" = "true" ]; then
            echo "MATLAB found; running run_ci.m"
            if ! matlab -batch "try, run_ci, exit(0); catch ME, disp(getReport(ME,'extended')); exit(1); end"; then
              echo "ok=false" >> $GITHUB_OUTPUT
              exit 1
            fi
            echo "ok=true" >> $GITHUB_OUTPUT
          else
            echo "MATLAB not available; writing empty reports so CI can proceed."
            # Minimal JUnit (0 tests)
            cat > test-results/results.xml <<'XML'
<?xml version="1.0" encoding="UTF-8"?>
<testsuites tests="0" failures="0" errors="0" time="0">
  <testsuite name="MATLAB" tests="0" failures="0" errors="0" time="0"/>
</testsuites>
XML
            # Minimal Cobertura (0% coverage)
            cat > code-coverage/coverage.xml <<'XML'
<?xml version="1.0" ?>
<!DOCTYPE coverage SYSTEM "http://cobertura.sourceforge.net/xml/coverage-04.dtd">
<coverage line-rate="0" branch-rate="0" version="MATLAB-CI" timestamp="0" lines-valid="0" lines-covered="0">
  <sources/>
  <packages/>
</coverage>
XML
            echo "ok=true" >> $GITHUB_OUTPUT
          fi

      - name: Summarize tests & coverage
        id: analyze
        run: |
          python3 - <<'PY' > _out.json
          import xml.etree.ElementTree as ET, os, json
          out = {"tests":0,"failures":0,"errors":0,"coverage":0.0,"failed_list":""}
          junit='test-results/results.xml'; cov='code-coverage/coverage.xml'
          if os.path.exists(junit):
            root=ET.parse(junit).getroot()
            for ts in root.iter('testsuite'):
              out["tests"]+=int(ts.get('tests',0)); out["failures"]+=int(ts.get('failures',0)); out["errors"]+=int(ts.get('errors',0))
              for tc in ts.iter('testcase'):
                f=tc.find('failure'); e=tc.find('error')
                if f is not None or e is not None:
                  name=f"{ts.get('name','suite')}.{tc.get('name','case')}"
                  msg=(f or e).get('message','').replace('\n',' ')[:200]
                  out["failed_list"] += f"{name}: {msg}\n"
          if os.path.exists(cov):
            root=ET.parse(cov).getroot()
            lv=int(root.attrib.get('lines-valid','0')); lc=int(root.attrib.get('lines-covered','0'))
            out["coverage"]= round(100.0*lc/(lv or 1),1)
          print(json.dumps(out))
          PY
          echo "tests=$(jq -r .tests _out.json)" >> $GITHUB_OUTPUT
          echo "failures=$(jq -r .failures _out.json)" >> $GITHUB_OUTPUT
          echo "errors=$(jq -r .errors _out.json)" >> $GITHUB_OUTPUT
          echo "coverage=$(jq -r .coverage _out.json)" >> $GITHUB_OUTPUT
          echo "failed_list<<EOF" >> $GITHUB_OUTPUT
          jq -r .failed_list _out.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Build CI-NOTES.md (non-AI)
        id: notes
        shell: bash
        run: |
          FILE=ci/CI-NOTES.md
          T=${{ steps.analyze.outputs.tests }}
          F=${{ steps.analyze.outputs.failures }}
          E=${{ steps.analyze.outputs.errors }}
          COV=${{ steps.analyze.outputs.coverage }}

          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE=${{ steps.shas.outputs.base }}
            HEAD=${{ steps.shas.outputs.head }}
            DIFF=$(git --no-pager diff --name-status "$BASE...$HEAD" | sed -e 's/^/  /')
          else
            DIFF=$(git --no-pager show --name-status --pretty="" ${{ github.sha }} | sed -e 's/^/  /')
          fi

          STATUS="All MATLAB checks passed."
          if [ "${{ steps.detect.outputs.available }}" != "true" ]; then
            STATUS="MATLAB not available on runner; checks skipped (placeholder reports)."
          elif [ "${{ steps.run.outputs.ok }}" != "true" ]; then
            STATUS="Checks failed; see details."
          fi

          {
            echo "# CI Notes (latest)"
            if [ "${{ github.event_name }}" = "pull_request" ]; then
              echo "- **PR:** #${{ github.event.number }}"
              echo "- **Base → Head:** \`${{ github.base_ref }}\` → \`${{ github.head_ref }}\`"
            else
              echo "- **Push to:** \`${{ github.ref_name }}\`"
            fi
            echo "- **Status:** ${STATUS}"
            echo "- **Ping:** @jtkillian"
            echo
            echo "## Metrics"
            echo "- Tests: ${T} | Failures: ${F} | Errors: ${E}"
            echo "- Coverage: ${COV}% (target ${MIN_COVERAGE}%)"
            echo
            echo "## Impact (files changed)"
            echo '```diff'
            echo "$DIFF"
            echo '```'
          } > "$FILE"
          echo "path=$FILE" >> $GITHUB_OUTPUT

      - uses: marocchino/sticky-pull-request-comment@v2
        if: ${{ github.event_name == 'pull_request' }}
        with:
          header: ci-notes
          path: ${{ steps.notes.outputs.path }}
        continue-on-error: true

      - name: One-time Initial AI Review (on open)
        if: ${{ github.event_name == 'pull_request' && env.CI_AI_ENABLED == '1' && github.event.action == 'opened' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MODEL_ID: ${{ env.MODEL_ID }}
        shell: bash
        run: |
          set -e
          if gh api repos/${{ github.repository }}/issues/${{ github.event.number }} --jq '.labels[].name' | grep -qx 'ci:ai-initialized'; then
            echo "Initial AI review already posted; skipping."
            exit 0
          fi
          TITLE="${{ github.event.pull_request.title }}"
          BODY=$(jq -r '.pull_request.body // ""' <<< '${{ toJson(github.event) }}')
          BASE=${{ steps.shas.outputs.base }}
          HEAD=${{ steps.shas.outputs.head }}
          DIFF=$(git --no-pager diff --unified=0 --no-color "$BASE...$HEAD" | head -c 15000)

          read -r -d '' PAYLOAD <<JSON
          {"model":"${MODEL_ID}",
           "messages":[
             {"role":"system","content":"You are a concise MATLAB PR reviewer."},
             {"role":"user","content":"Write a short PR summary (what/why/risks). Keep it under ~200 words.\n\nTitle: ${TITLE}\nBody: ${BODY}\nDiff (truncated):\n${DIFF}"}
           ],
           "temperature":0.2}
          JSON

          HTTP=$(curl -sS -w "%{http_code}" -o _ai.json -X POST https://models.github.ai/inference/chat/completions \
            -H "Accept: application/vnd.github+json" -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" -H "Content-Type: application/json" -d "$PAYLOAD" || echo "000")

          mkdir -p ci
          FILE=ci/CI-NOTES-INITIAL.md
          if [ "$HTTP" = "200" ]; then
            SUMMARY=$(jq -r '.choices[0].message.content // ""' _ai.json | head -c 4000)
            { echo "# Initial AI Review"; echo "$SUMMARY"; } > "$FILE"
          else
            { echo "# Initial AI Review"; echo "_AI quota unavailable; skipping initial summary._"; } > "$FILE"
          fi

          gh api repos/${{ github.repository }}/issues/${{ github.event.number }} -X POST -f labels='["ci:ai-initialized"]' >/dev/null 2>&1 || true
          gh pr comment ${{ github.event.number }} --body "$(printf '### (One-time) Initial AI Review\n\n%s' "$(cat "$FILE")")" >/dev/null 2>&1 || true

      - name: Upload artifacts (always present now)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: matlab-ci-artifacts
          path: |
            ci/CI-NOTES.md
            ci/CI-NOTES-INITIAL.md
            test-results/results.xml
            code-coverage/coverage.xml
          if-no-files-found: warn

      - name: Gate + notify (AI try -> fallback)
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MODEL_ID: ${{ env.MODEL_ID }}
          MIN_COVERAGE: ${{ env.MIN_COVERAGE }}
          T: ${{ steps.analyze.outputs.tests }}
          F: ${{ steps.analyze.outputs.failures }}
          E: ${{ steps.analyze.outputs.errors }}
          COV: ${{ steps.analyze.outputs.coverage }}
          FAILTXT: ${{ steps.analyze.outputs.failed_list }}
          MATLAB_AVAILABLE: ${{ steps.detect.outputs.available }}
          CI_AI_ENABLED: ${{ env.CI_AI_ENABLED }}
        shell: bash
        run: |
          # If MATLAB isn't available, treat as success (trial mode)
          if [ "$MATLAB_AVAILABLE" != "true" ]; then
            gh issue edit ${{ github.event.number }} --add-label "ci:passed" >/dev/null 2>&1 || true
            gh pr comment ${{ github.event.number }} --body "✅ CI ran in trial mode (no MATLAB on runner). Placeholder reports written." >/dev/null 2>&1 || true
            exit 0
          fi

          NEEDS=0
          if [ "$F" -gt 0 ] || [ "$E" -gt 0 ]; then NEEDS=1; fi
          if [ "$(printf '%.0f' "$COV")" -lt "${MIN_COVERAGE}" ]; then NEEDS=1; fi

          if [ $NEEDS -eq 0 ]; then
            gh issue edit ${{ github.event.number }} --add-label "ci:passed" >/dev/null 2>&1 || true
            gh pr comment ${{ github.event.number }} --body "✅ CI passed. @jtkillian you can \`/approve\` to auto-merge." >/dev/null 2>&1 || true
            exit 0
          fi

          gh issue edit ${{ github.event.number }} --add-label "ci:needs-work" >/dev/null 2>&1 || true

          CUR=$(gh api repos/${{ github.repository }}/issues/${{ github.event.number }} --jq '.labels[].name' 2>/dev/null | grep -E '^ci:rev-' | head -n1 || true)
          REV=${CUR#ci:rev-}; [ -z "$REV" ] && REV=0; NEXT=$((REV+1))
          [ -n "$CUR" ] && gh issue edit ${{ github.event.number }} --remove-label "$CUR" >/dev/null 2>&1 || true
          if [ $NEXT -gt ${{ env.MAX_REVISIONS }} ]; then
            gh issue edit ${{ github.event.number }} --add-label "ci:error-loop" >/dev/null 2>&1 || true
            gh pr comment ${{ github.event.number }} --body "⚠️ Auto-refinement cap (${{ env.MAX_REVISIONS }}) reached. @jtkillian please review." >/dev/null 2>&1 || true
            exit 1
          fi
          gh issue edit ${{ github.event.number }} --add-label "ci:rev-${NEXT}" >/dev/null 2>&1 || true

          if [ "${CI_AI_ENABLED}" = "1" ]; then
            TITLE="${{ github.event.pull_request.title }}"
            BODY=$(jq -r '.pull_request.body // ""' <<< '${{ toJson(github.event) }}')
            BASE=${{ steps.shas.outputs.base }}
            HEAD=${{ steps.shas.outputs.head }}
            DIFF=$(git --no-pager diff --unified=0 --no-color "$BASE...$HEAD" | head -c 16000)

            msgfile="_msg.md"; : > "$msgfile"
            printf "%s\n" "@copilot Please update this PR." >> "$msgfile"
            printf "\n%s\n" "AI fix plan (suggested):" >> "$msgfile"

            read -r -d '' PAYLOAD <<JSON
            {"model":"${MODEL_ID}",
             "messages":[
               {"role":"system","content":"You are a senior MATLAB maintainer generating small, targeted fix plans."},
               {"role":"user","content":"Given the failing tests and coverage gap, produce a short, actionable plan for Copilot: tests to add/repair and minimal code changes. Use bullets only.\nCoverage target: ${MIN_COVERAGE}%\nMetrics: tests=${T}, failures=${F}, errors=${E}, coverage=${COV}%\nFailing (trunc):\n${FAILTXT}\nTitle: ${TITLE}\nBody: ${BODY}\nDiff (trunc):\n${DIFF}"}
             ],
             "temperature":0.2}
            JSON

            HTTP=$(curl -sS -w "%{http_code}" -o _fix.json -X POST https://models.github.ai/inference/chat/completions \
              -H "Accept: application/vnd.github+json" -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "X-GitHub-Api-Version: 2022-11-28" -H "Content-Type: application/json" -d "$PAYLOAD" || echo "000")

            if [ "$HTTP" = "200" ]; then
              PLAN=$(jq -r '.choices[0].message.content // ""' _fix.json | head -c 4000)
              printf "\n%s\n\n%s\n" "$PLAN" "Guidance:" >> "$msgfile"
            else
              printf "\n%s\n" "_AI quota unavailable; posting deterministic instructions._" >> "$msgfile"
              printf "\n%s\n" "Guidance:" >> "$msgfile"
            fi

            printf "%s\n" "- Keep changes minimal & scoped." >> "$msgfile"
            printf "%s\n" "- Put tests in \`tests/\` using \`matlab.unittest\`." >> "$msgfile"
            printf "%s\n" "- Avoid interactive graphics; use \`rng default\`." >> "$msgfile"
            printf "%s\n" "- Re-run \`matlab -batch run_ci\` until green." >> "$msgfile"

            gh pr comment ${{ github.event.number }} --body "$(cat "$msgfile")" >/dev/null 2>&1 || true
            exit 1
          fi

          # Deterministic fallback (no models)
          msgfile="_msg.md"; : > "$msgfile"
          printf "%s\n\n" "@copilot Please update this PR." >> "$msgfile"
          printf "%s\n" "Goals:" >> "$msgfile"
          printf "%s\n" "1) Fix failing MATLAB tests/errors while preserving passing behavior." >> "$msgfile"
          printf "%s\n" "2) If coverage is below target, add focused \`matlab.unittest\` tests under \`tests/\` to reach the threshold." >> "$msgfile"
          printf "%s\n\n" "3) Re-run \`matlab -batch run_ci\` in your VM; push commits until green." >> "$msgfile"
          printf "%s\n" "Guidance:" >> "$msgfile"
          printf "%s\n" "- Keep changes minimal & scoped." >> "$msgfile"
          printf "%s\n" "- Place tests in \`tests/\`; avoid interactive graphics; use deterministic RNG (\`rng default\`)." >> "$msgfile"
          printf "%s\n" "- If a test reveals a bug, fix code in \`src/\` and keep the test." >> "$msgfile"
          gh pr comment ${{ github.event.number }} --body "$(cat "$msgfile")" >/dev/null 2>&1 || true
          exit 1
