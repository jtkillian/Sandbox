name: MATLAB CI + AI Review Loop

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  push:
    branches: ['**']
  workflow_dispatch: {}

permissions:
  contents: read
  pull-requests: write
  issues: write
  models: read

env:
  # Policy / gating
  ALLOWED_BASES: "bot/main,bots/main,dev,main"
  REQUIRED_HEAD_PREFIXES: "bot/copilot-,bot/codex-,bots/copilot-,bots/codex-"
  HUMAN_OWNER: "jtkillian"
  MAX_REVISIONS: "5"
  MIN_COVERAGE: "60"
  ALLOW_EMPTY: "1"            # allow blank repos to pass

  # AI controls (quota-safe)
  MODEL_ID: "openai/o4-mini"
  CI_AI_ENABLED: "1"
  CI_AI_ON_SUCCESS: "0"
  AI_ONLY_FOR_BOT_BRANCHES: "1"   # only @copilot ping for bot/* or bots/* PRs

jobs:
  test-and-review:
    name: test-and-review
    runs-on: ubuntu-latest
    environment: copilot

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 1 }

      # Auto-assign and auto-request reviewer (you) on PR open
      - name: Auto-assign & request reviewer
        if: ${{ and(eq(github.event_name, 'pull_request'), eq(github.event.action, 'opened')) }}
        env: { GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} }
        run: |
          gh pr edit ${{ github.event.number }} --add-assignee jtkillian || true
          gh pr edit ${{ github.event.number }} --add-reviewer jtkillian || true

      - name: Label PR as in-progress
        if: ${{ github.event_name == 'pull_request' }}
        uses: actions-ecosystem/action-add-labels@v1
        with: { labels: "ci:in-progress" }
        continue-on-error: true

      - name: Enforce agent branch policy (bots only)
        if: ${{ github.event_name == 'pull_request' }}
        id: policy
        shell: bash
        run: |
          if [ "${{ github.actor }}" = "${HUMAN_OWNER}" ]; then exit 0; fi
          if [[ "${{ github.head_ref }}" != bot/* && "${{ github.head_ref }}" != bots/* ]]; then
            echo "::error::Head must start with bot/ or bots/."; echo "policy_fail=true" >> $GITHUB_OUTPUT; exit 1; fi
          allowed="${ALLOWED_BASES//,/|}"
          if ! [[ "${{ github.base_ref }}" =~ ^(${allowed})$ ]]; then
            echo "::error::Base must be one of: ${ALLOWED_BASES}"; echo "policy_fail=true" >> $GITHUB_OUTPUT; exit 1; fi
          ok=0; IFS=',' read -ra PFX <<< "$REQUIRED_HEAD_PREFIXES"
          for p in "${PFX[@]}"; do [[ "${{ github.head_ref }}" == $p* ]] && ok=1; done
          if [[ $ok -eq 0 ]]; then
            echo "::error::Head must start with one of: ${REQUIRED_HEAD_PREFIXES}"; echo "policy_fail=true" >> $GITHUB_OUTPUT; exit 1; fi
        continue-on-error: true

      - name: Label wrong-branch policy
        if: ${{ and(eq(github.event_name, 'pull_request'), eq(steps.policy.outputs.policy_fail, 'true')) }}
        uses: actions-ecosystem/action-add-labels@v1
        with: { labels: "policy:wrong-branch" }
        continue-on-error: true

      # Fork-safe file list via API (no fragile git fetch of forks)
      - name: Compute changed files (PR-safe via API)
        if: ${{ github.event_name == 'pull_request' }}
        id: files
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          gh api repos/${{ github.repository }}/pulls/${{ github.event.number }}/files --paginate \
            --jq '.[] | (.status | ascii_downcase) as $s |
                 (if $s=="added" then "A"
                  elif $s=="modified" then "M"
                  elif $s=="removed" then "D"
                  elif $s=="renamed" then "R"
                  else "C" end) + "\t" + .filename' \
            > _files.txt
          sed -e 's/^/  /' _files.txt > _files_prefixed.txt || true
          echo "text<<EOF" >> $GITHUB_OUTPUT
          cat _files_prefixed.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Set up MATLAB (auto-licensing for public repos)
        uses: matlab-actions/setup-matlab@v2

      - name: Ensure minimal project structure (blank-repo safe)
        run: |
          mkdir -p src tests test-results code-coverage ci
          [ -f src/.gitkeep ]   || : > src/.gitkeep
          [ -f tests/.gitkeep ] || : > tests/.gitkeep

      - name: Detect run_ci.m presence
        id: has_run_ci
        shell: bash
        run: |
          if [ -f run_ci.m ]; then echo "present=true" >> $GITHUB_OUTPUT; else echo "present=false" >> $GITHUB_OUTPUT; fi

      # A) Use your custom CI script if present
      - name: Run MATLAB CI (run_ci.m)
        id: run_matlab
        if: steps.has_run_ci.outputs.present == 'true'
        uses: matlab-actions/run-command@v2
        continue-on-error: true
        with:
          command: |
            try
              run_ci
            catch ME
              disp(getReport(ME,'extended'));
              exit(2);
            end

      # B) Otherwise, run default tests with artifacts
      - name: Run MATLAB tests (auto-discover)
        id: run_tests
        if: steps.has_run_ci.outputs.present != 'true'
        uses: matlab-actions/run-tests@v2
        continue-on-error: true
        with:
          test-results-junit: test-results/results.xml
          code-coverage-cobertura: code-coverage/coverage.xml

      - name: Ensure reports exist (fallback)
        shell: bash
        run: |
          mkdir -p test-results code-coverage ci
          [ -f test-results/results.xml ] || printf '%s\n' '<?xml version="1.0" encoding="UTF-8"?>' \
            '<testsuites tests="0" failures="0" errors="0" time="0">' \
            '  <testsuite name="MATLAB" tests="0" failures="0" errors="0" time="0"/>' \
            '</testsuites>' > test-results/results.xml
          [ -f code-coverage/coverage.xml ] || printf '%s\n' '<?xml version="1.0" ?>' \
            '<!DOCTYPE coverage SYSTEM "http://cobertura.sourceforge.net/xml/coverage-04.dtd">' \
            '<coverage line-rate="0" branch-rate="0" version="MATLAB-CI" timestamp="0" lines-valid="0" lines-covered="0">' \
            '  <sources/>' \
            '  <packages/>' \
            '</coverage>' > code-coverage/coverage.xml
          [ -f ci/CI-NOTES.md ] || echo "# CI Notes (initial)" > ci/CI-NOTES.md

      - name: Summarize tests & coverage
        id: analyze
        run: |
          python3 - <<'PY' > _out.json
          import xml.etree.ElementTree as ET, os, json
          out = {"tests":0,"failures":0,"errors":0,"coverage":0.0,"failed_list":""}
          junit='test-results/results.xml'; cov='code-coverage/coverage.xml'
          if os.path.exists(junit):
            root=ET.parse(junit).getroot()
            for ts in root.iter('testsuite'):
              out["tests"]+=int(ts.get('tests',0)); out["failures"]+=int(ts.get('failures',0)); out["errors"]+=int(ts.get('errors',0))
              for tc in ts.iter('testcase'):
                f=tc.find('failure'); e=tc.find('error')
                if f is not None or e is not None:
                  name=f"{ts.get('name','suite')}.{tc.get('name','case')}"
                  msg=(f or e).get('message','').replace('\n',' ')[:200]
                  out["failed_list"] += f"{name}: {msg}\n"
          if os.path.exists(cov):
            root=ET.parse(cov).getroot()
            lv=int(root.attrib.get('lines-valid','0')); lc=int(root.attrib.get('lines-covered','0'))
            out["coverage"]= round(100.0*lc/(lv or 1),1)
          print(json.dumps(out))
          PY
          echo "tests=$(jq -r .tests _out.json)" >> $GITHUB_OUTPUT
          echo "failures=$(jq -r .failures _out.json)" >> $GITHUB_OUTPUT
          echo "errors=$(jq -r .errors _out.json)" >> $GITHUB_OUTPUT
          echo "coverage=$(jq -r .coverage _out.json)" >> $GITHUB_OUTPUT
          echo "failed_list<<EOF" >> $GITHUB_OUTPUT
          jq -r .failed_list _out.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Build CI-NOTES.md (fork-safe)
        id: notes
        shell: bash
        run: |
          FILE=ci/CI-NOTES.md
          T=${{ steps.analyze.outputs.tests }}
          F=${{ steps.analyze.outputs.failures }}
          E=${{ steps.analyze.outputs.errors }}
          COV=${{ steps.analyze.outputs.coverage }}
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            DIFF="${{ steps.files.outputs.text }}"
          else
            DIFF=$(git --no-pager show --name-status --pretty="" ${{ github.sha }} | sed -e 's/^/  /')
          fi
          {
            echo "# CI Notes (latest)"
            if [ "${{ github.event_name }}" = "pull_request" ]; then
              echo "- **PR:** #${{ github.event.number }}"
              echo "- **Base → Head:** \`${{ github.base_ref }}\` → \`${{ github.head_ref }}\`"
            else
              echo "- **Push to:** \`${{ github.ref_name }}\`"
            fi
            echo "- **Status:** (see checks below)"
            echo
            echo "## Metrics"
            echo "- Tests: ${T} | Failures: ${F} | Errors: ${E}"
            echo "- Coverage: ${COV}% (target ${MIN_COVERAGE}%)"
            echo
            echo "## Impact (files changed)"
            echo '```diff'
            echo "$DIFF"
            echo '```'
          } > "$FILE"
          echo "path=$FILE" >> $GITHUB_OUTPUT

      - uses: marocchino/sticky-pull-request-comment@v2
        if: ${{ github.event_name == 'pull_request' }}
        with:
          header: ci-notes
          path: ${{ steps.notes.outputs.path }}
        continue-on-error: true

      # One-time initial AI PR summary for bot PRs only (anti-injection)
      - name: One-time Initial AI Review (bot branches only)
        if: ${{ and(eq(github.event_name, 'pull_request'), eq(env.CI_AI_ENABLED, '1'), eq(env.AI_ONLY_FOR_BOT_BRANCHES, '1'), or(startsWith(github.head_ref, 'bot/'), startsWith(github.head_ref, 'bots/')), eq(github.event.action, 'opened')) }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MODEL_ID: ${{ env.MODEL_ID }}
        shell: bash
        run: |
          set -e
          if gh api repos/${{ github.repository }}/issues/${{ github.event.number }} --jq '.labels[].name' 2>/dev/null | grep -qx 'ci:ai-initialized'; then exit 0; fi
          TITLE="${{ github.event.pull_request.title }}"
          BODY=$(jq -r '.pull_request.body // ""' "$GITHUB_EVENT_PATH")
          DIFF="${{ steps.files.outputs.text }}"
          jq -Rn --arg model "$MODEL_ID" --arg title "$TITLE" --arg body "$BODY" --arg diff "$DIFF" \
            '{
              model: $model,
              messages: [
                {role:"system", content:"You are a concise MATLAB PR reviewer."},
                {role:"user", content: ("Write a short PR summary (what/why/risks). Keep it under ~200 words.\n\nTitle: " + $title + "\nBody: " + $body + "\nDiff (truncated):\n" + $diff)}
              ],
              temperature: 0.2
            }' > payload.json
          HTTP=$(curl -sS -w "%{http_code}" -o _ai.json -X POST https://models.github.ai/inference/chat/completions \
            -H "Accept: application/vnd.github+json" -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" -H "Content-Type: application/json" --data-binary @payload.json || echo "000")
          mkdir -p ci
          FILE=ci/CI-NOTES-INITIAL.md
          if [ "$HTTP" = "200" ]; then
            jq -r '.choices[0].message.content // ""' _ai.json | head -c 4000 | sed '1s/^/# Initial AI Review\n\n/' > "$FILE"
          else
            echo -e "# Initial AI Review\n\n_AI quota unavailable; skipping initial summary._" > "$FILE"
          fi
          gh api repos/${{ github.repository }}/issues/${{ github.event.number }} -X POST -f labels='["ci:ai-initialized"]' >/dev/null 2>&1 || true
          gh pr comment ${{ github.event.number }} --body-file "$FILE" >/dev/null 2>&1 || true

      - name: Upload artifacts (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: matlab-ci-artifacts
          path: |
            ci/CI-NOTES.md
            ci/CI-NOTES-INITIAL.md
            test-results/results.xml
            code-coverage/coverage.xml
          if-no-files-found: ignore

      # Gate + notify (AI try -> fallback). Allows empty repos to PASS.
      - name: Gate + notify (AI try -> fallback)
        id: gate
        if: ${{ and(always(), eq(github.event_name, 'pull_request')) }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MODEL_ID: ${{ env.MODEL_ID }}
          MIN_COVERAGE: ${{ env.MIN_COVERAGE }}
          ALLOW_EMPTY: ${{ env.ALLOW_EMPTY }}
          T: ${{ steps.analyze.outputs.tests }}
          F: ${{ steps.analyze.outputs.failures }}
          E: ${{ steps.analyze.outputs.errors }}
          COV: ${{ steps.analyze.outputs.coverage }}
          FAILTXT: ${{ steps.analyze.outputs.failed_list }}
          CI_AI_ENABLED: ${{ env.CI_AI_ENABLED }}
          AI_ONLY_FOR_BOT_BRANCHES: ${{ env.AI_ONLY_FOR_BOT_BRANCHES }}
        shell: bash
        run: |
          NEEDS=0
          if [ "$ALLOW_EMPTY" = "1" ] && [ "${T:-0}" = "0" ] && [ "${F:-0}" = "0" ] && [ "${E:-0}" = "0" ]; then
            NEEDS=0
          else
            if [ "${F:-0}" -gt 0 ] || [ "${E:-0}" -gt 0 ]; then NEEDS=1; fi
            if [ "$(printf '%.0f' "${COV:-0}")" -lt "${MIN_COVERAGE}" ]; then NEEDS=1; fi
          fi

          if [ $NEEDS -eq 0 ]; then
            gh issue edit ${{ github.event.number }} --add-label "ci:passed" >/dev/null 2>&1 || true
            echo "need_fix=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          gh issue edit ${{ github.event.number }} --add-label "ci:needs-work" >/dev/null 2>&1 || true

          CUR=$(gh api repos/${{ github.repository }}/issues/${{ github.event.number }} --jq '.labels[].name' 2>/dev/null | grep -E '^ci:rev-' | head -n1 || true)
          REV=${CUR#ci:rev-}; [ -z "$REV" ] && REV=0; NEXT=$((REV+1))
          [ -n "$CUR" ] && gh issue edit ${{ github.event.number }} --remove-label "$CUR" >/dev/null 2>&1 || true
          if [ $NEXT -gt ${{ env.MAX_REVISIONS }} ]; then
            gh issue edit ${{ github.event.number }} --add-label "ci:error-loop" >/dev/null 2>&1 || true
            gh pr comment ${{ github.event.number }} --body "⚠️ Auto-refinement cap (${{ env.MAX_REVISIONS }}) reached. @jtkillian please review." >/dev/null 2>&1 || true
            echo "need_fix=1" >> $GITHUB_OUTPUT
            exit 1
          fi
          gh issue edit ${{ github.event.number }} --add-label "ci:rev-${NEXT}" >/dev/null 2>&1 || true

          IS_BOT_BRANCH=0
          if [[ "${{ github.head_ref }}" == bot/* || "${{ github.head_ref }}" == bots/* ]]; then IS_BOT_BRANCH=1; fi

          if [ "${CI_AI_ENABLED}" = "1" ] && [ "${AI_ONLY_FOR_BOT_BRANCHES}" = "1" ] && [ $IS_BOT_BRANCH -eq 1 ]; then
            TITLE="${{ github.event.pull_request.title }}"
            BODY=$(jq -r '.pull_request.body // ""' "$GITHUB_EVENT_PATH")
            DIFF="${{ steps.files.outputs.text }}"
            jq -Rn --arg model "$MODEL_ID" \
                   --arg mincov "${MIN_COVERAGE}" \
                   --arg t "${T}" --arg f "${F}" --arg e "${E}" --arg cov "${COV}" \
                   --arg fails "${FAILTXT}" --arg title "$TITLE" --arg body "$BODY" --arg diff "$DIFF" \
              '{
                model: $model,
                messages: [
                  {role:"system",content:"You are a senior MATLAB maintainer generating small, targeted fix plans."},
                  {role:"user",content:
                    ("Given the failing tests and coverage gap, produce a short, actionable plan for Copilot: tests to add/repair and minimal code changes. Use bullets only.\nCoverage target: " + $mincov + "%\nMetrics: tests=" + $t + ", failures=" + $f + ", errors=" + $e + ", coverage=" + $cov + "%\nFailing (trunc):\n" + $fails + "\nTitle: " + $title + "\nBody: " + $body + "\nDiff (trunc):\n" + $diff)
                  }
                ],
                temperature: 0.2
              }' > payload.json

            HTTP=$(curl -sS -w "%{http_code}" -o _fix.json -X POST https://models.github.ai/inference/chat/completions \
              -H "Accept: application/vnd.github+json" -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "X-GitHub-Api-Version: 2022-11-28" -H "Content-Type: application/json" --data-binary @payload.json || echo "000")

            msgfile="_msg.md"; : > "$msgfile"
            printf "%s\n\n" "@copilot Please update this PR." >> "$msgfile"
            if [ "$HTTP" = "200" ]; then
              jq -r '.choices[0].message.content // ""' _fix.json | head -c 4000 >> "$msgfile"
            else
              printf "%s\n\n" "_AI quota unavailable; posting deterministic instructions." >> "$msgfile"
              printf "%s\n" "- Keep changes minimal & scoped." >> "$msgfile"
              printf "%s\n" "- Put tests in \`tests/\` using \`matlab.unittest\`." >> "$msgfile"
              printf "%s\n" "- Avoid interactive graphics; use \`rng default\`." >> "$msgfile"
              printf "%s\n" "- Re-run \`matlab -batch run_ci\` until green." >> "$msgfile"
            fi
            gh pr comment ${{ github.event.number }} --body-file "$msgfile" >/dev/null 2>&1 || true
            echo "need_fix=1" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Deterministic fallback for non-bot PRs or AI disabled
          msgfile="_msg.md"; : > "$msgfile"
          printf "%s\n\n" "@copilot Please update this PR." >> "$msgfile"
          printf "%s\n" "Goals:" >> "$msgfile"
          printf "%s\n" "1) Fix failing MATLAB tests/errors while preserving passing behavior." >> "$msgfile"
          printf "%s\n" "2) If coverage is below target, add focused \`matlab.unittest\` tests under \`tests/\` to reach the threshold." >> "$msgfile"
          printf "%s\n\n" "3) Re-run \`matlab -batch run_ci\` in your VM; push commits until green." >> "$msgfile"
          printf "%s\n" "Guidance:" >> "$msgfile"
          printf "%s\n" "- Keep changes minimal & scoped." >> "$msgfile"
          printf "%s\n" "- Place tests in \`tests/\`; use deterministic RNG (\`rng default\`)." >> "$msgfile"
          printf "%s\n" "- If a test reveals a bug, fix code in \`src/\` and keep the test." >> "$msgfile"
          gh pr comment ${{ github.event.number }} --body-file "$msgfile" >/dev/null 2>&1 || true
          echo "need_fix=1" >> $GITHUB_OUTPUT
          exit 1

      # Tidy labels at the very end
      - name: Cleanup labels
        if: ${{ and(always(), eq(github.event_name, 'pull_request')) }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          # Always drop "in-progress"
          gh issue edit ${{ github.event.number }} --remove-label "ci:in-progress" >/dev/null 2>&1 || true
          # If gate says we don't need fixes, remove needs-work and any rev counters
          if [ "${{ steps.gate.outputs.need_fix }}" = "0" ]; then
            gh issue edit ${{ github.event.number }} --remove-label "ci:needs-work" >/dev/null 2>&1 || true
            for L in $(gh issue view ${{ github.event.number }} --json labels --jq '.labels[].name' | grep '^ci:rev-' || true); do
              gh issue edit ${{ github.event.number }} --remove-label "$L" >/dev/null 2>&1 || true
            done
          fi
            for L in $(gh issue view ${{ github.event.number }} --json labels --jq '.labels[].name' | grep '^ci:rev-' || true); do
              gh issue edit ${{ github.event.number }} --remove-label "$L" >/dev/null 2>&1 || true
            done
          fi
